#!/usr/bin/env python3
"""This module contains various check tools for the scripts folder."""

import os  # path work

import requests  # session
from bbarchivist import barutils  # file system work
from bbarchivist import bbconstants  # constants
from bbarchivist import networkutils  # network tools
from bbarchivist import utilities  # little things

__author__ = "Thurask"
__license__ = "WTFPL v2"
__copyright__ = "2018 Thurask"


def return_radio_version(osversion, radioversion=None):
    """
    Increment radio version, if need be.

    :param osversion: OS version.
    :type osversion: str

    :param radioversion: Radio version, None if incremented.
    :type radioversion: str
    """
    if radioversion is None:
        radioversion = utilities.increment(osversion, 1)
    return radioversion


def sw_check_contingency(softwareversion):
    """
    Ask in the event software release isn't found.

    :param softwareversion: Software release version.
    :type softwareversion: str
    """
    if softwareversion == "SR not in system":
        print("SOFTWARE RELEASE NOT FOUND")
        cont = utilities.i2b("INPUT MANUALLY? Y/N: ")
        if cont:
            softwareversion = input("SOFTWARE RELEASE: ")
            swchecked = False
        else:
            print("\nEXITING...")
            raise SystemExit  # bye bye
    else:
        swchecked = True
    return softwareversion, swchecked


def return_sw_checked(softwareversion, osversion):
    """
    Check software existence, return boolean.

    :param softwareversion: Software release version.
    :type softwareversion: str

    :param osversion: OS version.
    :type osversion: str
    """
    if softwareversion is None:
        serv = bbconstants.SERVERS["p"]
        softwareversion = networkutils.sr_lookup(osversion, serv)
        softwareversion, swchecked = sw_check_contingency(softwareversion)
    else:
        swchecked = True
    return softwareversion, swchecked


def return_radio_sw_checked(altsw, radioversion):
    """
    Check radio software existence, return boolean.

    :param altsw: Software release version.
    :type altsw: str

    :param radioversion: Radio version.
    :type radioversion: str
    """
    if altsw == "checkme":
        serv = bbconstants.SERVERS["p"]
        testos = utilities.increment(radioversion, -1)
        altsw = networkutils.sr_lookup(testos, serv)
        altsw, altchecked = sw_check_contingency(altsw)
    else:
        altchecked = True
    return altsw, altchecked


def check_sw(baseurl, softwareversion, swchecked, altsw=False):
    """
    Check existence of software release.

    :param baseurl: Base URL (from http to hashed SW release).
    :type baseurl: str

    :param softwareversion: Software release.
    :type softwareversion: str

    :param swchecked: If we checked the sw release already.
    :type swchecked: bool

    :param altsw: If this is the radio-only release. Default is false.
    :type altsw: bool
    """
    message = "CHECKING RADIO SOFTWARE RELEASE..." if altsw else "CHECKING SOFTWARE RELEASE..."
    print(message)
    if not swchecked:
        check_sw_actual(baseurl, softwareversion)
    else:
        print("SOFTWARE RELEASE {0} EXISTS".format(softwareversion))


def check_sw_actual(baseurl, softwareversion):
    """
    Get the status of a software release.

    :param baseurl: Base URL (from http to hashed SW release).
    :type baseurl: str

    :param softwareversion: Software release.
    :type softwareversion: str
    """
    avlty = networkutils.availability(baseurl)
    if avlty:
        print("SOFTWARE RELEASE {0} EXISTS".format(softwareversion))
    else:
        check_sw_handle(softwareversion)


def check_sw_handle(softwareversion):
    """
    Handle non-existent software release.

    :param softwareversion: Software release.
    :type softwareversion: str
    """
    print("SOFTWARE RELEASE {0} NOT FOUND".format(softwareversion))
    cont = utilities.i2b("CONTINUE? Y/N: ")
    if not cont:
        print("\nEXITING...")
        raise SystemExit


def check_radio_sw(alturl, altsw, altchecked):
    """
    Check existence of radio software release.

    :param alturl: Radio base URL (from http to hashed SW release).
    :type alturl: str

    :param altsw: Radio software release.
    :type altsw: str

    :param altchecked: If we checked the sw release already.
    :type altchecked: bool
    """
    return check_sw(alturl, altsw, altchecked, True)


def check_altsw(altcheck=False):
    """
    Ask for and return alternate software release, if needed.

    :param altcheck: If we're using an alternate software release.
    :type altcheck: bool
    """
    if altcheck:
        altsw = input("RADIO SOFTWARE RELEASE (PRESS ENTER TO GUESS): ")
        if not altsw:
            altsw = "checkme"
    else:
        altsw = None
    return altsw


def check_os_single(osurl, osversion, device):
    """
    Check existence of single OS link.

    :param radiourl: Radio URL to check.
    :type radiourl: str

    :param radioversion: Radio version.
    :type radioversion: str

    :param device: Device family.
    :type device: int
    """
    osav = networkutils.availability(osurl)
    if not osav:
        print("{0} NOT AVAILABLE FOR {1}".format(osversion, bbconstants.DEVICES[device]))
        cont = utilities.i2b("CONTINUE? Y/N: ")
        if not cont:
            print("\nEXITING...")
            raise SystemExit


def check_os_bulk(osurls):
    """
    Check existence of list of OS links.

    :param osurls: OS URLs to check.
    :type osurls: list(str)
    """
    sess = requests.Session()
    for url in osurls:
        osav = networkutils.availability(url, sess)
        if osav:
            break
    else:
        check_os_bulk_handle()


def check_os_bulk_handle():
    """
    Handle no existing OS links.
    """
    print("OS VERSION NOT FOUND")
    cont = utilities.i2b("CONTINUE? Y/N: ")
    if not cont:
        print("\nEXITING...")
        raise SystemExit


def check_radio_single(radiourl, radioversion):
    """
    Check existence of single radio link.

    :param radiourl: Radio URL to check.
    :type radiourl: str

    :param radioversion: Radio version.
    :type radioversion: str
    """
    radav = networkutils.availability(radiourl)
    if not radav:
        print("RADIO VERSION NOT FOUND")
        cont = utilities.i2b("INPUT MANUALLY? Y/N: ")
        if cont:
            rad2 = input("RADIO VERSION: ")
            radiourl = radiourl.replace(radioversion, rad2)
            radioversion = rad2
        else:
            going = utilities.i2b("KEEP GOING? Y/N: ")
            if not going:
                print("\nEXITING...")
                raise SystemExit
    return radiourl, radioversion


def check_radio_bulk(radiourls, radioversion):
    """
    Check existence of list of radio links.

    :param radiourls: Radio URLs to check.
    :type radiourls: list(str)

    :param radioversion: Radio version.
    :type radioversion: str
    """
    sess = requests.Session()
    for url in radiourls:
        radav = networkutils.availability(url, sess)
        if radav:
            break
    else:
        radiourls, radioversion = check_radio_bulk_notfound(radiourls, radioversion)
    return radiourls, radioversion


def check_radio_bulk_notfound(radiourls, radioversion):
    """
    What to do if radio links aren't found.

    :param radiourls: Radio URLs to check.
    :type radiourls: list(str)

    :param radioversion: Radio version.
    :type radioversion: str
    """
    print("RADIO VERSION NOT FOUND")
    cont = utilities.i2b("INPUT MANUALLY? Y/N: ")
    if cont:
        radiourls, radioversion = check_radio_bulk_go(radiourls, radioversion)
    else:
        check_radio_bulk_stop()
    return radiourls, radioversion


def check_radio_bulk_go(radiourls, radioversion):
    """
    Replace radio version and URLs, and keep going.

    :param radiourls: Radio URLs to check.
    :type radiourls: list(str)

    :param radioversion: Radio version.
    :type radioversion: str
    """
    rad2 = input("RADIO VERSION: ")
    radiourls = [url.replace(radioversion, rad2) for url in radiourls]
    radioversion = rad2
    return radiourls, radioversion


def check_radio_bulk_stop():
    """
    Ask if we should keep going once no radio has been found.
    """
    going = utilities.i2b("KEEP GOING? Y/N: ")
    if not going:
        print("\nEXITING...")
        raise SystemExit


def bulk_avail(urllist):
    """
    Filter 404 links out of URL list.

    :param urllist: URLs to check.
    :type urllist: list(str)
    """
    sess = requests.Session()
    url2 = [x for x in urllist if networkutils.availability(x, sess)]
    return url2


def get_baseurls(softwareversion, altsw=None):
    """
    Generate base URLs for bar links.

    :param softwareversion: Software version.
    :type softwareversion: str

    :param altsw: Radio software version, if necessary.
    :type altsw: str
    """
    baseurl = utilities.create_base_url(softwareversion)
    alturl = utilities.create_base_url(altsw) if altsw else None
    return baseurl, alturl


def get_sz_executable(compmethod):
    """
    Get 7z executable.

    :param compmethod: Compression method.
    :type compmethod: str
    """
    if compmethod != "7z":
        szexe = ""
    else:
        print("CHECKING PRESENCE OF 7ZIP...")
        psz = utilities.prep_seven_zip(True)
        if psz:
            print("7ZIP OK")
            szexe = utilities.get_seven_zip(False)
        else:
            szexe = ""
            print("7ZIP NOT FOUND")
            cont = utilities.i2b("CONTINUE? Y/N ")
            if cont:
                print("FALLING BACK TO ZIP...")
                compmethod = "zip"
            else:
                print("\nEXITING...")
                raise SystemExit  # bye bye
    return compmethod, szexe


def test_bar_files(localdir, urllist):
    """
    Test bar files after download.

    :param localdir: Directory.
    :type localdir: str

    :param urllist: List of URLs to check.
    :type urllist: list(str)
    """
    print("TESTING BAR FILES...")
    brokenlist = []
    for file in os.listdir(localdir):
        brokenlist = test_bar_files_individual(file, localdir, urllist, brokenlist)
    if brokenlist:
        print("SOME FILES ARE BROKEN!")
        utilities.lprint(brokenlist)
        raise SystemExit
    else:
        print("BAR FILES DOWNLOADED OK")


def test_bar_files_individual(file, localdir, urllist, brokenlist):
    """
    Test bar file after download.

    :param file: Bar file to check.
    :type file: str

    :param localdir: Directory.
    :type localdir: str

    :param urllist: List of URLs to check.
    :type urllist: list(str)

    :param brokenlist: List of URLs to download later.
    :type brokenlist: list(str)
    """
    if file.endswith(".bar"):
        print("TESTING: {0}".format(file))
        thepath = os.path.abspath(os.path.join(localdir, file))
        brokens = barutils.bar_tester(thepath)
        brokenlist = bar_broken_individual(brokens, urllist, brokenlist)
    return brokenlist


def bar_broken_individual(brokens, urllist, brokenlist):
    """
    What to do if a downloaded bar file is broken.

    :param brokens: None if bar is OK, filename if it is not.
    :type brokens: str

    :param urllist: List of URLs to check.
    :type urllist: list(str)

    :param brokenlist: List of URLs to download later.
    :type brokenlist: list(str)
    """
    if brokens is not None:
        os.remove(brokens)
        for url in urllist:
            if brokens in url:
                brokenlist.append(url)
    return brokenlist


def test_signed_files(localdir):
    """
    Test signed files after extract.

    :param localdir: Directory.
    :type localdir: str
    """
    print("TESTING SIGNED FILES...")
    for file in os.listdir(localdir):
        if file.endswith(".bar"):
            print("TESTING: {0}".format(file))
            signname, signhash = barutils.retrieve_sha512(os.path.join(localdir, file))
            sha512ver = barutils.verify_sha512(os.path.join(localdir, signname.decode("utf-8")), signhash)
            if not sha512ver:
                print("{0} IS BROKEN".format((file)))
                break
    else:
        print("ALL FILES EXTRACTED OK")


def test_loader_files(localdir):
    """
    Test loader files after creation.

    :param localdir: Directory.
    :type localdir: str
    """
    if not utilities.is_windows():
        pass
    else:
        print("TESTING LOADER FILES...")
        brokens = utilities.verify_bulk_loaders(localdir)
        if brokens:
            print("BROKEN FILES:")
            utilities.lprint(brokens)
            raise SystemExit
        else:
            print("ALL FILES CREATED OK")


def test_single_loader(loaderfile):
    """
    Test single loader file after creation.

    :param loaderfile: File to check.
    :type loaderfile: str
    """
    if not utilities.is_windows():
        pass
    else:
        print("TESTING LOADER...")
        if not utilities.verify_loader_integrity(loaderfile):
            print("{0} IS BROKEN!".format(os.path.basename(loaderfile)))
            raise SystemExit
        else:
            print("LOADER CREATED OK")


def clean_swrel(swrelset):
    """
    Clean a list of software release lookups.

    :param swrelset: List of software releases.
    :type swrelset: set(str)
    """
    for i in swrelset:
        if i != "SR not in system" and i is not None:
            swrelease = i
            break
    else:
        swrelease = ""
    return swrelease
